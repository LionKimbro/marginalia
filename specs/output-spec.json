{
  "marginalia_outputs": {
    "version": "0.3",
    "version_creation_date": "2026-01-14",
    "assumes_meta_spec": "marginalia.meta.v0.1",
    "common_item_shape": {
      "fields": {
        "id": {
          "type": "string",
          "semantics": "Globally unique identifier for this inventory item. Human-declared anchors begin with '#'. Generated structural IDs use prefixes such as 'mod:', 'fn:', 'class:', 'var:', 'anchor:', followed by a module path, followed by the symbol."
        },
        "symbol": {
          "type": "string",
          "semantics": "Fully-qualified symbolic name of the item within the codebase. For modules this is the module path; for functions, classes, and vars this includes the module path and enclosing scopes (e.g. 'pkg.mod.Class.method'); for anchors this is the declared anchor name.  Primary display name of the item."
        },
        "symbol_type": {
          "type": "string",
          "allowed": [
            "module",
            "function",
            "class",
            "var",
            "anchor"
          ],
          "semantics": {
            "module": "A Python source module (file-level unit.)",
            "function": "A Python function definition.",
            "class": "A Python class definition.",
            "var": "A Python-level name binding that assigns a value to an identifier.",
            "anchor": "A meta-declared symbol that may not correspond to a Python identifier binding."
          }
        },
        "source_file": {
          "type": "string"
        },
        "line_number": {
          "type": "integer"
        },
        "raw": {
          "type": "array", 
          "semantics": "Exact original # meta and # doc comment lines, including leading # and all content (including any @anchor token), with trailing newline removed." 
        },
        "systems": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "unique_items": true,
          "case_sensitivity": "insensitive",
          "normalization": "lowercase",
          "semantics": "Architectural systems or subsystems this item participates in (not Python modules). Hierarchical names using dots are allowed, e.g. 'mqtt.transport'."
        },
        "roles": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "unique_items": true,
          "case_sensitivity": "insensitive",
          "normalization": "lowercase",
          "semantics": "Architectural roles this item fulfills.  For example: engine, adaptor, facade, mainloop, dispatcher, calculation."
        },
        "threads": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "unique_items": true,
          "case_sensitivity": "insensitive",
          "normalization": "lowercase"
        },
        "callers": {
          "type": [
            "array",
            "string",
            "integer"
          ],
          "mutual_exclusivity": true,
          "invariant": "Exactly one representation form must be used.",
          "semantics": {
            "array": "Explicit list of calling symbols.",
            "string": "\"*\" indicates general-purpose or unbounded callers.",
            "integer": "Expected number of distinct call sites."
          },
          "allowed_forms": {
            "array": {
              "items": {
                "type": "string",
                "description": "Name of a calling function or symbol."
              },
              "unique_items": true,
              "meaning": "Explicit list of symbols that are expected to call this symbol."
            },
            "string": {
              "allowed_values": [
                "*"
              ],
              "meaning": "\"*\" indicates general-purpose usage with unbounded or unknown callers."
            },
            "integer": {
              "minimum": 0,
              "meaning": "Expected number of distinct call sites."
            }
          },
          "null_allowed": false
        },
        "flags": {
          "type": "string",
          "semantics": "A string interpreted as a set of single-character flags; each character represents one flag.",
          "constraints": {
            "unique_characters": true
          }
        },
        "custom": {
          "type": "object",
          "value_type": "array<string>",
          "semantics": "Contains all parsed meta keys not recognized as reserved keys (systems, threads, callers, flags). Each key maps to an array of string values.",
          "default": {}
        },
        "nests": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "unique_items": true,
          "semantics": "Inventory IDs of symbols lexically nested within this item (module → classes/functions/vars; class → methods/vars; function → nested defs)."
        },
        "assign_type": {
          "type": "string",
          "semantics": "Declared expected type or role of a variable binding, especially for global or registry variables (e.g. 'dict[str, Service]', 'MQTTConnection', 'WorkerState'). Informational, not type-checked."
        },
        "doc": {
          "type": "array",
          "semantics": "Human-written documentation text associated with this item, derived from Python docstrings or '# doc:' meta lines."
        }
      },
      "field_requirements": {
        "required": [
          "id",
          "symbol",
          "symbol_type",
          "source_file",
          "line_number",
          "raw",
          "systems",
          "roles",
          "threads",
          "callers",
          "flags",
          "custom",
          "nests",
          "assign_type",
          "doc"
        ],
        "missing_field_behavior": "error",
        "null_values": "disallowed",
        "defaults": {
          "systems": [],
          "roles": [],
          "threads": [],
          "callers": [],
          "flags": "",
          "custom": {},
          "nests": [],
          "assign_type": "",
          "doc": ""
        },
        "execution_invariants": [
          "All fields listed in 'required' are always present.",
          "No field value is ever null.",
          "Empty collections are represented as [] or {}.",
          "Empty textual fields are represented as empty strings."
        ]
      }
    },
    "outputs": {
      "inventory": {
        "name": "inventory_output",
        "description": "Flat list of all annotated symbols discovered during analysis.",
        "structure": {
          "type": "array",
          "items": {
            "$ref": "#/marginalia_outputs/common_item_shape"
          }
        },
        "ordering": {
          "default": "source order",
          "optional": [
            "symbol",
            "source_file"
          ]
        },
        "semantics": "Complete, lossless enumeration of Marginalia-bound symbols."
      },
      "indexes": {
        "name": "indexes_output",
        "description": "Multiple inverted indexes over the same symbol inventory.  The by-id index is the canonical identity map; all cross-item references and structural overlays should resolve items via id using this index.  Other indexes are presentation-oriented views.",
        "structure": {
          "by-id": {
            "<id>": {
              "$ref": "#/marginalia_outputs/common_item_shape"
            },
            "semantics": "Canonical identity index. Maps each globally unique item id to its full inventory record. All cross-item references should resolve through this index."
          },
          "by-symbol": {
            "<symbol-key>": {
              "$ref": "#/marginalia_outputs/common_item_shape"
            }
          },
          "by-file": {
            "<filename>": {
              "<symbol-key>": {
                "$ref": "#/marginalia_outputs/common_item_shape"
              }
            }
          },
          "by-system": {
            "<system-name>": {
              "<symbol-key>": {
                "$ref": "#/marginalia_outputs/common_item_shape"
              }
            }
          },
          "by-thread": {
            "<thread-name>": {
              "<symbol-key>": {
                "$ref": "#/marginalia_outputs/common_item_shape"
              }
            }
          },
          "by-flag": {
            "<flag-character>": {
              "<symbol-key>": {
                "$ref": "#/marginalia_outputs/common_item_shape"
              }
            }
          }
        },
        "symbol_key_rules": {
          "base_key": "<symbol-name>",
          "collision_resolution": {
            "strategy": "serial_suffix",
            "format": "<symbol-name> (<n>)",
            "scope": "per index bucket",
            "ordering": "source order within the bucket"
          },
          "identity_note": "Symbol keys are presentation keys only; item identity is defined by id."
        },
        "indexing_rules": {
          "multi_membership": "A symbol may appear in multiple index buckets.",
          "missing_keys": "Symbols lacking a key are omitted from that index.",
          "unknown_meta_keys": "Preserved in item.custom but not indexed unless explicitly configured.",
          "ordering": "undefined (JSON object); consumers may sort by key if desired"
        },
        "semantics": "Perspective-based projections over a shared symbol inventory."
      }
    },
    "invariants": [
      "All indexed outputs must reference items present in inventory output.",
      "No indexed output may introduce new symbols.",
      "Item identity is defined by id.",
      "All cross-item references must be resolvable via the by-id index."
    ],
    "non_goals": [
      "Deduplication across files",
      "Semantic validation of meta values",
      "Conflict resolution between indexes"
    ]
  }
}
