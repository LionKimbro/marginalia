{
  "marginalia": {
    "version": "0.2",
    "spec_id": "marginalia.comment-spec.v0.2",
    "spec_filename": "comment-spec_v0-2.json",
    "purpose": "Provide structured, comment-based metadata for describing the architectural and functional organization of Python code without affecting runtime behavior.",
    "scope": "Static source analysis",
    "assumes_output_spec": "marginalia.output-spec.v0.3",
    "binding_rule": "A meta comment applies to the immediately following bindable symbol; if an @anchor is present, the comment binds to that anchor; if a #id is present, it defines the canonical identifier for the bound symbol.",
    "syntax": {
      "comment_channels": {
        "meta": {
          "comment_prefix": "# meta:",
          "entry_format": "key=value_list",
          "separator": "whitespace",
          "value_separator": ",",
          "key_character_set": "a-zA-Z0-9_-",
          "value_character_set": "a-zA-Z0-9_.-#*:/[]",
          "anchor_prefix": "@",
          "anchor_character_set": "a-zA-Z0-9_-",
          "id_prefix": "#",
          "id_character_set": "a-zA-Z0-9_:-./",
          "id_multiplicity": "at_most_one",
          "case_sensitive": true
        },
        "doc": {
          "comment_prefix": "# doc:",
          "content_format": "free_text",
          "whitespace": "preserve_after_prefix",
          "line_continuation": true,
          "empty_doc_lines_allowed": true
        }
      }
    },
    "examples": [
      {
        "description": "Binding metadata to a g-var entry using explicit anchors",
        "source": [
          "g = {",
          "  # meta: @X systems=coordinates roles=state threads=main flags=g",
          "  \"X\": 0,",
          "",
          "  # meta: @Y systems=coordinates roles=state threads=main flags=g",
          "  \"Y\": 0",
          "}"
        ],
        "binding_result": {
          "X": {
            "symbol_type": "anchor",
            "systems": [
              "coordinates"
            ],
            "roles": [
              "state"
            ],
            "threads": [
              "main"
            ],
            "flags": "g"
          },
          "Y": {
            "symbol_type": "anchor",
            "systems": [
              "coordinates"
            ],
            "roles": [
              "state"
            ],
            "threads": [
              "main"
            ],
            "flags": "g"
          }
        }
      }
    ],
    "parsing_rules": {
      "model": "streaming_accumulator",
      "accumulator": {
        "buffers": [
          "meta",
          "doc"
        ],
        "initial_state": "empty",
        "on_comment_line": {
          "meta": "merge_into_meta_buffer",
          "doc": "append_to_doc_buffer"
        },
        "merge_rules": {
          "sets_and_arrays": "extend",
          "scalars": "overwrite",
          "conflicts": "last_wins"
        }
      },
      "drain_events": {
        "explicit_anchor": {
          "trigger": "meta line containing @anchor",
          "behavior": "flush_accumulator_into_named_symbol",
          "symbol_creation": "create_if_missing",
          "after_flush": "clear_accumulator"
        },
        "bindable_symbol": {
          "trigger": "function | class | var | module definition",
          "behavior": "flush_accumulator_into_symbol",
          "after_flush": "clear_accumulator"
        }
      },
      "ignored_lines": {
        "description": "Lines that are neither comment channels nor bindable symbols do not affect the accumulator."
      },
      "end_of_file": {
        "if_accumulator_not_empty": "error",
        "error_class": "orphaned_metadata",
        "fail_policy_interaction": {
          "halt": "raise_error_and_exit",
          "warn": "emit_warning_and_discard"
        }
      },
      "docstring_enrichment": {
        "pass": "post_scan_ast",
        "applies_to": [
          "function",
          "class"
        ],
        "source": "python_ast",
        "extraction_method": "ast.get_docstring",
        "merge_target": "item.doc",
        "merge_behavior": {
          "when_doc_exists": "append",
          "when_doc_missing": "set",
          "precedence": "meta_over_docstring",
          "separator": "\n\n"
        },
        "matching_strategy": {
          "primary": "source_file_and_line_range",
          "fallback": "qualified_symbol_name"
        },
        "notes": "Docstrings are not available to the streaming scanner and are integrated after initial inventory construction."
      }
    },
    "binding": {
      "targets": [
        "function",
        "class",
        "var",
        "module",
        "anchor"
      ],
      "scope_limit": "until_next_drain_event",
      "anchor_binding": {
        "requires_explicit_anchor": true,
        "creates_symbol": true
      },
      "symbol_binding": {
        "requires_syntax_detection": true,
        "creates_symbol": false
      },
      "id_binding": {
        "optional": true,
        "creates_symbol": false,
        "overrides_derived_id": true,
        "scope": "bound_symbol",
        "id_semantics": "Globally unique canonical identity used in inventory and indexes."
      }
    },
    "reserved_keys": {
      "systems": {
        "type": "set<string>",
        "description": "Architectural systems or subsystems this symbol participates in.",
        "normalization": "lowercase",
        "semantics": "Conceptual systems, not Python modules. Dot hierarchy allowed.",
        "examples": [
          "mqtt.transport",
          "filetalk.patchboard",
          "ui.canvas"
        ]
      },
      "roles": {
        "type": "set<string>",
        "description": "Architectural roles fulfilled by this symbol.",
        "normalization": "lowercase",
        "examples": [
          "engine",
          "dispatcher",
          "facade",
          "worker"
        ]
      },
      "threads": {
        "type": "set<string>",
        "description": "Narrative or execution-path contexts in which this symbol participates.",
        "normalization": "lowercase",
        "semantics": "Conceptual execution or responsibility paths; may align with OS threads or async tasks but are not required to.",
        "examples": [
          "startup",
          "ui-loop",
          "background"
        ]
      },
      "callers": {
        "type": "array<string> | string | integer",
        "description": "Approximate cardinality or identity of call sites.",
        "allowed_values": {
          "*": "Unbounded or general-purpose usage",
          "array": "Explicit list of calling symbols",
          "integer": "Expected number of distinct call sites"
        },
        "semantics": "Informational only; may be validated by tooling but never enforced."
      },
      "flags": {
        "type": "string",
        "description": "Set of single-character categorical flags encoded as a string.",
        "constraints": {
          "unique_characters": true
        },
        "semantics": "Opaque to Marginalia; interpreted only by consuming tools."
      },
      "assign_type": {
        "type": "string",
        "description": "Declared expected role or type of a variable binding.",
        "semantics": "Informational annotation for global or registry variables.",
        "examples": [
          "dict[str, Service]",
          "MQTTConnection",
          "WorkerState"
        ]
      },
      "doc": {
        "type": "string",
        "description": "Inline human documentation associated with this symbol.",
        "sources": [
          "# doc: meta lines",
          "Python docstrings"
        ],
        "semantics": "Merged into inventory item documentation field.",
        "docstring_scope": {
          "allowed_symbol_types": [
            "function",
            "class"
          ],
          "disallowed_symbol_types": [
            "var",
            "anchor",
            "module"
          ],
          "semantics": "Docstrings are only collected from Python syntactic constructs that support them."
        }
      }
    },
    "custom_keys": {
      "allowed": true,
      "storage": "item.custom",
      "value_form": "array<string>",
      "semantics": "All non-reserved meta keys are preserved verbatim for downstream tooling.",
      "normalization": "none"
    },
    "structural_tokens": {
      "anchor": {
        "prefix": "@",
        "creates_symbol": true,
        "symbol_type": "anchor",
        "binding": "only when explicitly present"
      },
      "id": {
        "prefix": "#",
        "creates_symbol": false,
        "overrides_derived_id": true
      }
    },
    "output_mapping": {
      "raw": "Full original meta comment line is preserved verbatim.",
      "systems": "From reserved key systems",
      "roles": "From reserved key roles",
      "threads": "From reserved key threads",
      "callers": "From reserved key callers",
      "flags": "From reserved key flags",
      "assign_type": "From reserved key assign_type",
      "doc": "Concatenation of accumulated '# doc:' comment lines from streaming scan and docstrings merged during post-scan AST enrichment per parsing_rules.docstring_enrichment.",
      "custom": "All non-reserved keys mapped to arrays of strings"
    },
    "non_goals": [
      "Runtime behavior modification",
      "Static type enforcement",
      "Dependency resolution",
      "Call graph enforcement",
      "Semantic validation of architectural claims"
    ]
  }
}
